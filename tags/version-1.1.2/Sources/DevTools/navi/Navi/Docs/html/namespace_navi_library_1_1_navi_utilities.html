<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>NaviLibrary: NaviLibrary::NaviUtilities Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="namespaces.html"><span>Namespace List</span></a></li>
    <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
  </ul>
</div>
<div class="nav">
<b>NaviLibrary</b>::<a class="el" href="namespace_navi_library_1_1_navi_utilities.html">NaviUtilities</a></div>
<h1>NaviLibrary::NaviUtilities Namespace Reference</h1>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_navi_library_1_1_navi_utilities_1_1_inline_vector.html">InlineVector</a></td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="class_navi_library_1_1_navi_utilities_1_1_inline_vector.html">InlineVector</a><br>
&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_navi_library_1_1_navi_utilities.html#8a643b8257e0fdba864898a1fc6464ac">Strings</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_navi_library_1_1_navi_utilities.html#5f16ec11c31e15218b77c30cc93bb6b9">getCurrentWorkingDirectory</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_navi_library_1_1_navi_utilities.html#56f6118e251d69b942ffd2b402dec680">htmlToDataURI</a> (std::string htmlString)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_navi_library_1_1_navi_utilities.html#55a9e9d08b14c45b8c737ba3c1dac29e">resourceToDataURI</a> (const std::string &amp;resFileName, const std::string &amp;resourceGroupName=Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_navi_library_1_1_navi_utilities.html#04f045763536c6836712656e46605d61">translateLocalProtocols</a> (std::string &amp;strToTranslate)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_navi_library_1_1_navi_utilities.html#c5aba62bbe1d9bca6027c620ef06579d">translateResourceProtocols</a> (std::string &amp;strToTranslate)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_navi_library_1_1_navi_utilities.html#53da47ad7c0a8fa5a0a544b9d611e72a">encodeURIComponent</a> (std::wstring strToEncode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::wstring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_navi_library_1_1_navi_utilities.html#8b6c0fd34df6b3fed0cb3962f44ae5f4">decodeURIComponent</a> (std::string strToDecode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_navi_library_1_1_navi_utilities.html#8b1d7d0e637d17e4f40fae46c8b77b00">lowerString</a> (std::string strToLower)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_navi_library_1_1_navi_utilities.html#9ca927f3b32d025f451a872391e6092e">isPrefixed</a> (const std::string &amp;sourceString, const std::string &amp;prefix, bool ignoreCase=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_navi_library_1_1_navi_utilities.html#e5e5dacd9fc52e0b24c6bf09f7eb57db">isNumeric</a> (const std::string &amp;numberString)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class NumberType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_navi_library_1_1_navi_utilities.html#cd8611924319c7b4d2333323c4aaeefd">numberToString</a> (const NumberType &amp;number)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class NumberType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">NumberType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_navi_library_1_1_navi_utilities.html#69096bb7e2cc6465d7eab8471570a877">toNumber</a> (const std::string &amp;numberString)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::wstring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_navi_library_1_1_navi_utilities.html#19f87c98dd65481f4500e4b3ea460092">toWide</a> (const std::string &amp;stringToConvert)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_navi_library_1_1_navi_utilities.html#474f82023e2c1f61d937ee6702fe3b45">toMultibyte</a> (const std::wstring &amp;wstringToConvert)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_navi_library_1_1_navi_utilities.html#71bb2057b665d88a32278fcc1cbee740">setLocale</a> (const std::string &amp;localeLanguage=&quot;&quot;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_navi_library_1_1_navi_utilities.html#d56f3c77906c1cd15bd09cd1530af6a7">replaceAll</a> (std::string &amp;sourceStr, const std::string &amp;replaceWhat, const std::string &amp;replaceWith)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::vector<br>
&lt; std::string &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_navi_library_1_1_navi_utilities.html#d53770ac30b06094e18316f7abc2855a">split</a> (const std::string &amp;sourceStr, const std::string &amp;delimiter, bool ignoreEmpty=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::map<br>
&lt; std::string,<br>
 std::string &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_navi_library_1_1_navi_utilities.html#04ea05a11259a70df49c860f504e3571">splitToMap</a> (const std::string &amp;sourceStr, const std::string &amp;pairDelimiter, const std::string &amp;keyValueDelimiter, bool ignoreEmpty=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_navi_library_1_1_navi_utilities.html#e0b1bab27695b440493c2019e1883e79">join</a> (const std::vector&lt; std::string &gt; &amp;sourceVector, const std::string &amp;delimiter, bool ignoreEmpty=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_navi_library_1_1_navi_utilities.html#0ce3da8c50cb19ea207346eb98d745a7">joinFromMap</a> (const std::map&lt; std::string, std::string &gt; &amp;sourceMap, const std::string &amp;pairDelimiter, const std::string &amp;keyValueDelimiter, bool ignoreEmpty=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_navi_library_1_1_navi_utilities.html#8c02468b07ac5ac941e3536007265c80">hexStringToRGB</a> (const std::string &amp;hexString, unsigned char &amp;R, unsigned char &amp;G, unsigned char &amp;B)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_navi_library_1_1_navi_utilities.html#4f4bba508100e9bbd66447944afaa05c">encodeBase64</a> (const std::string &amp;strToEncode)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Various public utilities that are internally used by by NaviLibrary but may be of some use to you. <hr><h2>Typedef Documentation</h2>
<a class="anchor" name="8a643b8257e0fdba864898a1fc6464ac"></a><!-- doxytag: member="NaviLibrary::NaviUtilities::Strings" ref="8a643b8257e0fdba864898a1fc6464ac" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_navi_library_1_1_navi_utilities_1_1_inline_vector.html">InlineVector</a>&lt;std::string&gt; <a class="el" href="class_navi_library_1_1_navi_utilities_1_1_inline_vector.html">NaviLibrary::NaviUtilities::Strings</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is just a simple way to quickly make inline string vectors.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>For example: <div class="fragment"><pre class="fragment">        <span class="comment">// Before:</span>
        vector&lt;string&gt; myVector;
        myVector.push_back(<span class="stringliteral">"hello"</span>);
        myVector.push_back(<span class="stringliteral">"awesome"</span>);
        myVector.push_back(<span class="stringliteral">"world"</span>);
        someFunction(myVector);

        <span class="comment">// After:</span>
        someFunction(<a class="code" href="namespace_navi_library_1_1_navi_utilities.html#8a643b8257e0fdba864898a1fc6464ac">Strings</a>(<span class="stringliteral">"hello"</span>)(<span class="stringliteral">"awesome"</span>)(<span class="stringliteral">"world"</span>));
</pre></div> </dd></dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="8b6c0fd34df6b3fed0cb3962f44ae5f4"></a><!-- doxytag: member="NaviLibrary::NaviUtilities::decodeURIComponent" ref="8b6c0fd34df6b3fed0cb3962f44ae5f4" args="(std::string strToDecode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring NaviLibrary::NaviUtilities::decodeURIComponent           </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>strToDecode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is a C++ mirror implementation that I wrote for the Javascript function 'decodeURIComponent'. For more info: <a href="http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Functions:decodeURIComponent">http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Functions:decodeURIComponent</a><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>strToDecode</em>&nbsp;</td><td>The standard string to decode. Should be previously encoded by 'encodeURIComponent'.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A wide string containing the decoded version of strToDecode. You may use <a class="el" href="namespace_navi_library_1_1_navi_utilities.html#474f82023e2c1f61d937ee6702fe3b45">toMultibyte()</a> to convert this to a standard string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4f4bba508100e9bbd66447944afaa05c"></a><!-- doxytag: member="NaviLibrary::NaviUtilities::encodeBase64" ref="4f4bba508100e9bbd66447944afaa05c" args="(const std::string &amp;strToEncode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string NaviLibrary::NaviUtilities::encodeBase64           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>strToEncode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Encodes a string into Base64.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>strToEncode</em>&nbsp;</td><td>The string to encode.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The Base64-encoded representation of the passed string.</dd></dl>
The following is freely-available code by René Nyffenegger Obtained from: <a href="http://www.adp-gmbh.ch/cpp/common/base64.html">http://www.adp-gmbh.ch/cpp/common/base64.html</a> 
</div>
</div><p>
<a class="anchor" name="53da47ad7c0a8fa5a0a544b9d611e72a"></a><!-- doxytag: member="NaviLibrary::NaviUtilities::encodeURIComponent" ref="53da47ad7c0a8fa5a0a544b9d611e72a" args="(std::wstring strToEncode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string NaviLibrary::NaviUtilities::encodeURIComponent           </td>
          <td>(</td>
          <td class="paramtype">std::wstring&nbsp;</td>
          <td class="paramname"> <em>strToEncode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is a C++ mirror implementation that I wrote for the Javascript function 'encodeURIComponent'. For more info: <a href="http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Functions:encodeURIComponent">http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Functions:encodeURIComponent</a><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>strToEncode</em>&nbsp;</td><td>The wide string to encode. You may use <a class="el" href="namespace_navi_library_1_1_navi_utilities.html#19f87c98dd65481f4500e4b3ea460092">toWide()</a> to convert a standard string to wide.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A standard string containing the encoded (UTF-8 percent-escaped) version of strToEncode. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5f16ec11c31e15218b77c30cc93bb6b9"></a><!-- doxytag: member="NaviLibrary::NaviUtilities::getCurrentWorkingDirectory" ref="5f16ec11c31e15218b77c30cc93bb6b9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string NaviLibrary::NaviUtilities::getCurrentWorkingDirectory           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the current working directory for the executable.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A string containing the current working directory. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8c02468b07ac5ac941e3536007265c80"></a><!-- doxytag: member="NaviLibrary::NaviUtilities::hexStringToRGB" ref="8c02468b07ac5ac941e3536007265c80" args="(const std::string &amp;hexString, unsigned char &amp;R, unsigned char &amp;G, unsigned char &amp;B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NaviLibrary::NaviUtilities::hexStringToRGB           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>hexString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char &amp;&nbsp;</td>
          <td class="paramname"> <em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char &amp;&nbsp;</td>
          <td class="paramname"> <em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a Hex Color String to R, G, B values.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hexString</em>&nbsp;</td><td>A hex color string in format: "#XXXXXX"</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>R</em>&nbsp;</td><td>The Red value to change. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>G</em>&nbsp;</td><td>The Green value to change. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>The Blue value to change.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns whether or not the conversion was successful. </dd></dl>

</div>
</div><p>
<a class="anchor" name="56f6118e251d69b942ffd2b402dec680"></a><!-- doxytag: member="NaviLibrary::NaviUtilities::htmlToDataURI" ref="56f6118e251d69b942ffd2b402dec680" args="(std::string htmlString)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string NaviLibrary::NaviUtilities::htmlToDataURI           </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>htmlString</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a String containing HTML into an equivalent Data URI, replaces all 'local://' and 'resource://group/filename' instances with their correct equivalent.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>htmlString</em>&nbsp;</td><td>The string containing the HTML to convert.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A string containing a Data URI with 'text/html' mime-type, data encoded in Base64. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e5e5dacd9fc52e0b24c6bf09f7eb57db"></a><!-- doxytag: member="NaviLibrary::NaviUtilities::isNumeric" ref="e5e5dacd9fc52e0b24c6bf09f7eb57db" args="(const std::string &amp;numberString)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NaviLibrary::NaviUtilities::isNumeric           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>numberString</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks whether or not a string is 'numeric' in nature (begins with actual, parseable digits).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>numberString</em>&nbsp;</td><td>The string to check. </td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Strings beginning with 'true'/'false' (regardless of case) are numeric.</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether or not the string is numeric (can be successfully parsed into a number). </dd></dl>

</div>
</div><p>
<a class="anchor" name="9ca927f3b32d025f451a872391e6092e"></a><!-- doxytag: member="NaviLibrary::NaviUtilities::isPrefixed" ref="9ca927f3b32d025f451a872391e6092e" args="(const std::string &amp;sourceString, const std::string &amp;prefix, bool ignoreCase=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NaviLibrary::NaviUtilities::isPrefixed           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>sourceString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>ignoreCase</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks whether or not a string is prefixed with a certain prefix.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sourceString</em>&nbsp;</td><td>The string to check.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prefix</em>&nbsp;</td><td>The prefix to search for.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ignoreCase</em>&nbsp;</td><td>Whether or not to ignore differences in case, default is true.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether or not a match was found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e0b1bab27695b440493c2019e1883e79"></a><!-- doxytag: member="NaviLibrary::NaviUtilities::join" ref="e0b1bab27695b440493c2019e1883e79" args="(const std::vector&lt; std::string &gt; &amp;sourceVector, const std::string &amp;delimiter, bool ignoreEmpty=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string NaviLibrary::NaviUtilities::join           </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>sourceVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>ignoreEmpty</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Joins a string vector into a single string. (Effectively does the inverse of <a class="el" href="namespace_navi_library_1_1_navi_utilities.html#d53770ac30b06094e18316f7abc2855a">NaviUtilities::split</a>)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sourceVector</em>&nbsp;</td><td>The string vector to join.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delimiter</em>&nbsp;</td><td>What to delimit each token by.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ignoreEmpty</em>&nbsp;</td><td>Whether or not to ignore empty strings within the string vector. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0ce3da8c50cb19ea207346eb98d745a7"></a><!-- doxytag: member="NaviLibrary::NaviUtilities::joinFromMap" ref="0ce3da8c50cb19ea207346eb98d745a7" args="(const std::map&lt; std::string, std::string &gt; &amp;sourceMap, const std::string &amp;pairDelimiter, const std::string &amp;keyValueDelimiter, bool ignoreEmpty=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string NaviLibrary::NaviUtilities::joinFromMap           </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>sourceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>pairDelimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>keyValueDelimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>ignoreEmpty</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Joins a string map into a single string. (Effectively does the inverse of <a class="el" href="namespace_navi_library_1_1_navi_utilities.html#04ea05a11259a70df49c860f504e3571">NaviUtilities::splitToMap</a>)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sourceMap</em>&nbsp;</td><td>The string map to join.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pairDelimiter</em>&nbsp;</td><td>What to delimit each pair by.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keyValueDelimiter</em>&nbsp;</td><td>What to delimit each key-value by.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ignoreEmpty</em>&nbsp;</td><td>Whether or not to ignore empty string values within the string map. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8b1d7d0e637d17e4f40fae46c8b77b00"></a><!-- doxytag: member="NaviLibrary::NaviUtilities::lowerString" ref="8b1d7d0e637d17e4f40fae46c8b77b00" args="(std::string strToLower)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string NaviLibrary::NaviUtilities::lowerString           </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>strToLower</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a string into its lower-case equivalent.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>strToLower</em>&nbsp;</td><td>The standard string to convert to lower-case.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A standard string containing the equivalent lower-case representation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cd8611924319c7b4d2333323c4aaeefd"></a><!-- doxytag: member="NaviLibrary::NaviUtilities::numberToString" ref="cd8611924319c7b4d2333323c4aaeefd" args="(const NumberType &amp;number)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NumberType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string NaviLibrary::NaviUtilities::numberToString           </td>
          <td>(</td>
          <td class="paramtype">const NumberType &amp;&nbsp;</td>
          <td class="paramname"> <em>number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a Number (int, float, double, bool, etc.) to a String.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>number</em>&nbsp;</td><td>The number (usually of type int, float, double, bool, etc.) to convert to a String.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>If the conversion succeeds, returns the string equivalent of the number, otherwise an empty string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d56f3c77906c1cd15bd09cd1530af6a7"></a><!-- doxytag: member="NaviLibrary::NaviUtilities::replaceAll" ref="d56f3c77906c1cd15bd09cd1530af6a7" args="(std::string &amp;sourceStr, const std::string &amp;replaceWhat, const std::string &amp;replaceWith)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NaviLibrary::NaviUtilities::replaceAll           </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>sourceStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>replaceWhat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>replaceWith</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replaces all instances of 'replaceWhat' with 'replaceWith' inside a source string.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sourceStr</em>&nbsp;</td><td>The string to do this to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>replaceWhat</em>&nbsp;</td><td>What to be replaced.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>replaceWith</em>&nbsp;</td><td>All occurrences of 'replaceWhat' will be replaced with this.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of instances replaced within 'sourceStr'. </dd></dl>

</div>
</div><p>
<a class="anchor" name="55a9e9d08b14c45b8c737ba3c1dac29e"></a><!-- doxytag: member="NaviLibrary::NaviUtilities::resourceToDataURI" ref="55a9e9d08b14c45b8c737ba3c1dac29e" args="(const std::string &amp;resFileName, const std::string &amp;resourceGroupName=Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string NaviLibrary::NaviUtilities::resourceToDataURI           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>resFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>resourceGroupName</em> = <code>Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts an Ogre Resource into an equivalent Data URI. Additional 'local://' and 'resource://' specifier translation will occur on the following filetypes: '.html, .htm, .shtml, .php, .asp, .xhtml, .xml, .js, .cgi, .css'<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>resFileName</em>&nbsp;</td><td>The filename of the Ogre Resource</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>resourceGroupName</em>&nbsp;</td><td>The name of the Ogre Resource Group to search in.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A string containing a Data URI with an automatically-identified mime-type, data encoded in Base64. </dd></dl>

</div>
</div><p>
<a class="anchor" name="71bb2057b665d88a32278fcc1cbee740"></a><!-- doxytag: member="NaviLibrary::NaviUtilities::setLocale" ref="71bb2057b665d88a32278fcc1cbee740" args="(const std::string &amp;localeLanguage=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NaviLibrary::NaviUtilities::setLocale           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>localeLanguage</em> = <code>&quot;&quot;</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the current locale, used for 'toMultibyte()'. If you never call this, the default is usually "English".<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>localeLanguage</em>&nbsp;</td><td>The name of the locale language to set. An empty string sets this to the current locale of the OS. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d53770ac30b06094e18316f7abc2855a"></a><!-- doxytag: member="NaviLibrary::NaviUtilities::split" ref="d53770ac30b06094e18316f7abc2855a" args="(const std::string &amp;sourceStr, const std::string &amp;delimiter, bool ignoreEmpty=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::string &gt; &amp; NaviLibrary::NaviUtilities::split           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>sourceStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>ignoreEmpty</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Splits a string up into a series of tokens (contained within a string vector), delimited by a certain string.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sourceStr</em>&nbsp;</td><td>The string to split up.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delimiter</em>&nbsp;</td><td>What to delimit the source string by.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ignoreEmpty</em>&nbsp;</td><td>Whether or not to ignore empty tokens. (usually created by 2 or more immediately adjacent delimiters)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A string vector containing a series of ordered tokens. </dd></dl>

</div>
</div><p>
<a class="anchor" name="04ea05a11259a70df49c860f504e3571"></a><!-- doxytag: member="NaviLibrary::NaviUtilities::splitToMap" ref="04ea05a11259a70df49c860f504e3571" args="(const std::string &amp;sourceStr, const std::string &amp;pairDelimiter, const std::string &amp;keyValueDelimiter, bool ignoreEmpty=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; std::string, std::string &gt; &amp; NaviLibrary::NaviUtilities::splitToMap           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>sourceStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>pairDelimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>keyValueDelimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>ignoreEmpty</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A more advanced form of splitting, parses a string into a string map. Exceptionally useful for use with Query Strings.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sourceStr</em>&nbsp;</td><td>The string to parse.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pairDelimiter</em>&nbsp;</td><td>What to delimit pairs by.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keyValueDelimiter</em>&nbsp;</td><td>What to delimit key-values by.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ignoreEmpty</em>&nbsp;</td><td>Whether or not to ignore empty values. Empty pairs will always be ignored.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A string map containing the parsed equivalent of the passed string.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>For example: <div class="fragment"><pre class="fragment">        std::string myQueryString = <span class="stringliteral">"name=Bob&amp;sex=none&amp;color=purple"</span>;
        std::map&lt;std::string,std::string&gt; myMap = <a class="code" href="namespace_navi_library_1_1_navi_utilities.html#04ea05a11259a70df49c860f504e3571">splitToMap</a>(myQueryString, <span class="stringliteral">"&amp;"</span>, <span class="stringliteral">"="</span>);
        std::string myColor = myMap[<span class="stringliteral">"color"</span>]; <span class="comment">// myColor is now 'purple' </span>
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="474f82023e2c1f61d937ee6702fe3b45"></a><!-- doxytag: member="NaviLibrary::NaviUtilities::toMultibyte" ref="474f82023e2c1f61d937ee6702fe3b45" args="(const std::wstring &amp;wstringToConvert)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string NaviLibrary::NaviUtilities::toMultibyte           </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&nbsp;</td>
          <td class="paramname"> <em>wstringToConvert</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a wide string to a multibyte string (standard string), based on the current locale.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wstringToConvert</em>&nbsp;</td><td>The wide string to convert.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The multibyte-equivalent of the passed string, based on the current locale. </dd></dl>

</div>
</div><p>
<a class="anchor" name="69096bb7e2cc6465d7eab8471570a877"></a><!-- doxytag: member="NaviLibrary::NaviUtilities::toNumber" ref="69096bb7e2cc6465d7eab8471570a877" args="(const std::string &amp;numberString)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NumberType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">NumberType NaviLibrary::NaviUtilities::toNumber           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>numberString</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a String to a Number.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>&lt;NumberType&gt;</em>&nbsp;</td><td>The NumberType (int, float, bool, double, etc.) to convert to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numberString</em>&nbsp;</td><td>A string containing a valid numeric sequence (can check using <a class="el" href="namespace_navi_library_1_1_navi_utilities.html#e5e5dacd9fc52e0b24c6bf09f7eb57db">isNumeric()</a>). </td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Strings beginning with 'true'/'false' (regardless of case) are numeric and will be converted accordingly.</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>If conversion succeeds, returns a number of type 'NumberType', otherwise returns a '0' equivalent. </dd></dl>

</div>
</div><p>
<a class="anchor" name="19f87c98dd65481f4500e4b3ea460092"></a><!-- doxytag: member="NaviLibrary::NaviUtilities::toWide" ref="19f87c98dd65481f4500e4b3ea460092" args="(const std::string &amp;stringToConvert)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring NaviLibrary::NaviUtilities::toWide           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>stringToConvert</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a multibyte string (standard string) to a wide string.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stringToConvert</em>&nbsp;</td><td>The multibyte (standard) string to convert.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The wide-equivalent of the passed string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="04f045763536c6836712656e46605d61"></a><!-- doxytag: member="NaviLibrary::NaviUtilities::translateLocalProtocols" ref="04f045763536c6836712656e46605d61" args="(std::string &amp;strToTranslate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NaviLibrary::NaviUtilities::translateLocalProtocols           </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>strToTranslate</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replaces all 'local://' instances within a String with the correct NaviLocal directory.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>For example: <div class="fragment"><pre class="fragment">local://filename.html --&gt; file:///C:\My Application\NaviLocal\filename.html </pre></div></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>strToTranslate</em>&nbsp;</td><td>The string to translate. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c5aba62bbe1d9bca6027c620ef06579d"></a><!-- doxytag: member="NaviLibrary::NaviUtilities::translateResourceProtocols" ref="c5aba62bbe1d9bca6027c620ef06579d" args="(std::string &amp;strToTranslate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NaviLibrary::NaviUtilities::translateResourceProtocols           </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>strToTranslate</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replaces all '"resource://Group/Filename.ext"' with an equivalent Data URI of the Ogre Resource. Syntax of '"resource://Filename.ext"' assumes the Resource Group is DEFAULT_RESOURCE_GROUP_NAME. If the Ogre Resource is not found, the 'resource://' specifier instance is skipped. Please note that this statement is required to be encased within double-quotes to be valid. Certain filetypes will be additionally parsed for local/resource specifiers and translated accordingly.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>strToTranslate</em>&nbsp;</td><td>The string to translate. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Sep 22 16:56:17 2007 for NaviLibrary by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.3 </small></address>
</body>
</html>
